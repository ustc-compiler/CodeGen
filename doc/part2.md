## Phi指令生成——数据移动
在开始本关前，请确认你已经阅读了[实训主页](../shixuns/24ufsnih/challenges)的实训说明全文。

本实验框架提供的代码对于Phi指令的处理正如前面所述，需要你实现的是数据移动部分的代码，请在`{WorkSpace}/src/Backend/DataMoving.cpp`文件中补全`data_move`函数，它的定义如下：
- 参数`src`表示数据来源，它是一系列数据来源位置组成的`vector`，数据来源可能是立即数、寄存器或者栈上的地址；
- 参数`dst`表示数据目的地，它是一系列数据目的位置组成的`vector`，可能是寄存器或者栈地址，与`src`等长，源和目的按照在容器中的位置相对应；
- 参数`cmpop`表示条件执行所需条件，你编写的数据移动函数生成的所有数据指令都需要使用此条件执行

在实现过程中，你需要注意：
- 来源和目的有可能包含相同的寄存器或栈地址，但不一定是对应的，比如可能有如下输入：
  ```
  src = {r1,r2,r3}
  dst = {r2,r3,r1}
  ```
  按照Phi指令的语义，这些移动应该是并行执行，也就是说移动后 r1, r2, r3 三个寄存器中装的分别是 r3, r1, r2 在移动之前的值。你需要想办法解决这里的依赖问题，这也是这部分实验的重点。**欢迎各种奇思妙想**。
- 数据来源可能有重复，但目的地不会重复，来源有重复时，**寄存器和常数将是`IR2asm::RegLoc`类的不同对象，而栈地址将是`IR2asm::RegBase`的相同对象**，这是由于准备数据来源的时候没有检查是否重复，但栈地址是直接从`stack_map`中读出，所以相同的栈地址对应的是同一个对象。
- 对于有两个后继的基本块，本实验框架给出的Phi指令生成将会在分支指令成功和失败的跳转之前分别调用一次你写的数据移动函数，并传入条件执行所需要的条件，你不需要处理条件执行部分。
- 本实验框架已给出单个数据的移动代码(`single_data_move`)，它将单个源位置的数据移动到目的位置，同时附加条件码，你需要传入一个临时寄存器以完成将常数存入栈位置或将栈上数据移动到栈上另一位置。由于不做临时寄存器保护，当使用临时寄存器时`single_data_move`将**破坏临时寄存器的值**。
- 在本实验框架实现的代码生成部分，被调用者会在被调用时保存`lr`寄存器，退出前恢复`lr`寄存器的值，所以你可以使用`lr`，但是`single_data_move`有可能破坏`lr`寄存器的值（不论你传进什么临时寄存器），如果你要使用`lr`寄存器，请记得保存。

> 注：本实验3关是相辅相成的，因此本关不会单独对寄存器分配算法正确性做评测，本关点击评测即可通关。在第三关本实验会评测关卡1寄存器分配 + 关卡2Phi指令生成 + 关卡3栈空间分配这3关一起的正确性。

### 实验提示
- 需要防止破坏临时寄存器里的值，除非你确信这个寄存器是没用的，所以你可以在寄存器分配阶段就直接预留临时寄存器不分配出去。但是这种做法将导致可用寄存器变少，增大栈空间，而栈的数据移动是有些麻烦和费时的。
- 充分利用栈，这是一个非常大的连续内存空间，所以一个实现上简单处理数据相关的方法是把源全都压到栈上再逐个放到目的中去。这当然会产生性能损失，但因为本实验没有性能要求，所以用这种方法也是可以接受的。但我们仍希望你开动脑筋，尽力提高这部分的性能。

### 可能用到的参考文档
- 寄存器分配数据结构、接口说明文档在`doc/RegAlloc.md`
完成第一关寄存器分配所必要的接口和数据结构说明。

- 汇编指令相关数据结构定义接口文档在`doc/AsmValue.md`。
在后端中，所有的位置（寄存器、立即数、栈地址等）使用本实验软件包提供的接口进行表示。

- 栈帧结构与ABI约定相关文档在`doc/StackFrameAndABI.md`。
在第三关栈空间分配实验中你需要按照约定进行栈空间分配。
